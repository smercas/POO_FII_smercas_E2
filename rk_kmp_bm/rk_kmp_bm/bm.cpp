#include "bm.h"
#include "Marker.h"
#include "kmp.h"

int64_t* bm::calculate_last_bad_character(FILE* file, const char* pattern) {
	int64_t* bc = new int64_t[ALPHABET_LENGTH];
	if (bc == nullptr) {
		fprintf(file, "ERROR: Failed to allocate memory on the heap.\n");
		exit(1);
	}
	else {
		fprintf(file, "Calculating the 'bad char' array (or, simply put, the last appearance of all the characters that're within the alphabet in the pattern).\n");
		uint64_t i = 0;
		while (i < ALPHABET_LENGTH) {
			bc[i] = -1;
			++i;
		}
		i = 0;
		while (i < ALPHABET_LENGTH) {
			fprintf(file, "%*c ", 3, i + 'A');
			++i;
		}
		fseek(file, -1, SEEK_CUR);
		fprintf(file, "\n");
		i = 0;
		while (i < ALPHABET_LENGTH) {
			fprintf(file, "%*lld ", 3, bc[i]);
			++i;
		}
		fseek(file, -1, SEEK_CUR);
		fprintf(file, "\n");
		i = 0;
		while (i < strlen(pattern)) {
			bc[pattern[i] - 'A'] = i;
			fprintf(file, "%*d ", (pattern[i] - 'A') * 4 + 3, bc[pattern[i] - 'A']);
			fseek(file, -1, SEEK_CUR);
			fprintf(file, "\n");
			++i;
		}
		i = 0;
		while (i < ALPHABET_LENGTH) {
			fprintf(file, "%*lld ", 3, bc[i]);
			++i;
		}
		fseek(file, -1, SEEK_CUR);
		fprintf(file, "\n\n");
	}
	return bc;
}
int64_t* bm::calculate_last_bad_character_lean(FILE* file, const char* pattern) {
	int64_t* bc = new int64_t[ALPHABET_LENGTH];
	if (bc == nullptr) {
		fprintf(file, "ERROR: Failed to allocate memory on the heap.\n");
		exit(1);
	}
	else {
		uint64_t i = 0;
		while (i < ALPHABET_LENGTH) {
			bc[i] = -1;
			++i;
		}
		i = 0;
		while (i < strlen(pattern)) {
			bc[pattern[i] - 'A'] = i;
			++i;
		}
	}
	return bc;
}
int64_t* bm::calculate_second_to_last_good_suffix(FILE* file, const char* pattern) {
	int64_t* f = kmp::calculate_failure_lean(file, pattern);
	int64_t* gs = new int64_t[ALPHABET_LENGTH];
	if (gs == nullptr) {
		fprintf(file, "ERROR: Failed to allocate memory on the heap.\n");
		exit(1);
	}
	else {
		fprintf(file, "Calculating the 'good suffix' array (no idea how to explain this one).\n");
		fprintf(file, "The first step revolves around cases where the good suffix does not appear in the pattern more than once.\n");
		fprintf(file, "In those cases, it's helpful to think there're some imaginary characters at the beginning that would fit the good suffix perfectly.\n");
		fprintf(file, "The way to get the number of imaginary characters needed for a certain position is to subtract the length of the suffix that starts from\n\
						the i-th position from the length of the biggest proper frontier of the pattern. Hopefully this'll still makes sense whenever I come back.\n\n");
		uint64_t i = 0;
		while (i < strlen(pattern) - f[strlen(pattern)]) {
			gs[i] = f[strlen(pattern)] - (strlen(pattern) - i);	//the biggest prefix minus the length of the current prefix
			fprintf(file, "pattern:\t\t\t%*s\n", 2 * strlen(pattern) - i - f[strlen(pattern)], pattern);
			fprintf(file, "good suffix:\t\t%*s\ngood suffix match:\t%s\n", 2 * strlen(pattern) - i - f[strlen(pattern)], pattern + i, pattern + i);
			fprintf(file, "\t\t\t\t");
			Marker::print(file, 2, strlen(pattern) + 3, strlen(pattern) + 3, ' ', '-', ' ', 's', '+');
			fprintf(file, " | strlen(pattern)(%llu)\n\t\t\t\t", strlen(pattern));
			Marker::print(file, strlen(pattern) - i + 3, strlen(pattern) + 3, strlen(pattern) + 3, ' ', '-', ' ', '+', '+');
			fprintf(file, " | strlen(pattern)(%llu) - i(%llu) (=%llu)\n\t\t\t\t", strlen(pattern), i, strlen(pattern) - i);
			Marker::print(file, strlen(pattern) - i - f[strlen(pattern)] + 3, strlen(pattern) - i + 3, strlen(pattern) + 3, ' ', '-', ' ', 'f', '+');
			fprintf(file, " | strlen(pattern)(%llu) - i(%llu) - f[strlen(pattern](%llu) (=%llu)\n\t\t\t\t", strlen(pattern), i, f[strlen(pattern)], strlen(pattern) - i - f[strlen(pattern)]);
			fprintf(file, "\n");
			++i;
		}
		i = 0;
		while (i <= strlen(pattern)) {
			fprintf(file, "%*lld ", 3, i);
			++i;
		}
		fseek(file, -1, SEEK_CUR);
		fprintf(file, "\n");
		i = 0;
		while (i < strlen(pattern)) {
			fprintf(file, "%*c ", 3, pattern[i]);
			++i;
		}
		fseek(file, -1, SEEK_CUR);
		fprintf(file, "\n");
		i = 0;
		while (i < strlen(pattern) - f[strlen(pattern)]) {
			fprintf(file, "%*lld ", 3, gs[i]);
			++i;
		}
		while (i <= strlen(pattern)) {
			fprintf(file, "%*lld ", 3, 0);
			++i;
		}
		fseek(file, -1, SEEK_CUR);
		fprintf(file, "\n\n");
		fprintf(file, "The rest of the values(from %llu to %llu) will be calculated using the reverse of the fail function generated by the reverse of the pattern.\n\n", i, strlen(pattern) - 1);
		delete[] f;
		char* lmao = new char[strlen(pattern) + 1];
		if (lmao == nullptr) {
			fprintf(file, "ERROR: Failed to allocate memory on the heap.\n");
			exit(1);
		}
		strcpy_s(lmao, strlen(pattern) + 1, pattern);
		f = kmp::calculate_failure_lean(file, _strrev(lmao));
		if (f == nullptr) {
			fprintf(file, "ERROR: Failed to allocate memory on the heap.\n");
			exit(1);
		}
		i = 0;
		while (i < strlen(lmao)) {
			fprintf(file, "%*c ", 3, lmao[i]);
			++i;
		}
		fseek(file, -1, SEEK_CUR);
		fprintf(file, "\n");
		i = 0;
		while (i <= strlen(lmao)) {
			fprintf(file, "%*d ", 3, f[i]);
			++i;
		}
		fseek(file, -1, SEEK_CUR);
		fprintf(file, "\n\nthe above will turn into:\n\n");
		i = 0;
		while (i < strlen(lmao)) {
			fprintf(file, "%*c ", 3, lmao[i]);
			++i;
		}
		fseek(file, -1, SEEK_CUR);
		fprintf(file, "\n");
		i = strlen(lmao);
		while (i <= strlen(lmao)) {
			fprintf(file, "%*lld ", 3, f[i]);
			--i;
		}
		fseek(file, -1, SEEK_CUR);
		fprintf(file, "\n\n");
		delete[] lmao;
		fprintf(file, "Now we only need to iterate through the failure array and update the good suffix array.\n\n");
		i = 0;
		while (i <= strlen(pattern)) {
			fprintf(file, "%*lld ", 3, i);
			++i;
		}
		fseek(file, -1, SEEK_CUR);
		fprintf(file, "\n");
		i = 0;
		while (i < strlen(pattern) - f[strlen(pattern)]) {
			fprintf(file, "%*lld ", 3, gs[i]);
			++i;
		}
		while (i <= strlen(pattern)) {
			fprintf(file, "%*lld ", 3, 0);
			++i;
		}
		fseek(file, -1, SEEK_CUR);
		fprintf(file, "\n");
		i = strlen(pattern);
		while (i > 0) {
			gs[strlen(pattern) - f[i]] = strlen(pattern) - i;
			fprintf(file, "%*d ", (strlen(pattern) - f[i]) * 4 + 3, gs[strlen(pattern) - f[i]]);
			fseek(file, -1, SEEK_CUR);
			fprintf(file, "\n");
			--i;
		}
		i = 0;
		while (i <= strlen(pattern)) {
			fprintf(file, "%*lld ", 3, gs[i]);
			++i;
		}
		fseek(file, -1, SEEK_CUR);
		fprintf(file, "\n");
		delete[] f;
	}
	return gs;
}
int64_t* bm::calculate_second_to_last_good_suffix_lean(FILE* file, const char* pattern) {
	int64_t* f = kmp::calculate_failure_lean(file, pattern);
	int64_t* gs = new int64_t[ALPHABET_LENGTH];
	if (gs == nullptr) {
		fprintf(file, "ERROR: Failed to allocate memory on the heap.\n");
		exit(1);
	}
	else {
		uint64_t i = 0;
		while (i < strlen(pattern) - f[strlen(pattern)]) {
			gs[i] = f[strlen(pattern)] - (strlen(pattern) - i);
			++i;
		}
		delete[] f;
		char* lmao = new char[strlen(pattern) + 1];
		if (lmao == nullptr) {
			fprintf(file, "ERROR: Failed to allocate memory on the heap.\n");
			exit(1);
		}
		strcpy_s(lmao, strlen(pattern) + 1, pattern);
		f = kmp::calculate_failure_lean(file, _strrev(lmao));
		if (f == nullptr) {
			fprintf(file, "ERROR: Failed to allocate memory on the heap.\n");
			exit(1);
		}
		delete[] lmao;
		i = strlen(pattern);
		while (i > 0) {
			gs[strlen(pattern) - f[i]] = strlen(pattern) - i;
			--i;
		}
		delete[] f;
	}
	return gs;
}
void bm::find_all_occurences(FILE* file, const char* text, const char* pattern) {
	if (strlen(text) < strlen(pattern)) {
		fprintf(file, "ERROR: Text '%s' is smaller than the pattern '%s', there's no point in matching them.\n", text, pattern);
		exit(1);
	}
	else {
		int64_t* bc = bm::calculate_last_bad_character(file, pattern);
		int64_t* gs = bm::calculate_second_to_last_good_suffix(file, pattern);
		if (bc == nullptr || gs == nullptr) {
			fprintf(file, "ERROR: Failed to allocate memory on the heap.\n");
			exit(1);
		}
		fprintf(file, "preprocessing:\nbad_char_function =\n");
		uint64_t i = 0, k = 0;
		int64_t shiftbc, shiftgs;
		while (i < ALPHABET_LENGTH) {
			fprintf(file, "%*c ", 3, i + 'A');
			++i;
		}
		fseek(file, -1, SEEK_CUR);
		fprintf(file, "\n");
		i = 0;
		while (i < ALPHABET_LENGTH) {
			fprintf(file, "%*d ", 3, bc[i]);
			++i;
		}
		fseek(file, -1, SEEK_CUR);
		fprintf(file, "\ngood_suffix_function =\n");
		i = 0;
		while (i < strlen(pattern)) {
			fprintf(file, "%*c ", 3, pattern[i]);
			++i;
		}
		fseek(file, -1, SEEK_CUR);
		fprintf(file, "\n");
		i = 0;
		while (i <= strlen(pattern)) {
			fprintf(file, "%*d ", 3, gs[i]);
			++i;
		}
		fseek(file, -1, SEEK_CUR);
		fprintf(file, "\n\n");
		Marker::print(file, -1, strlen(text), strlen(text), ' ', '-', ' ', 's', '+');
		fprintf(file, " | strlen(text)(%llu)\n", strlen(text));
		Marker::print(file, strlen(text) - strlen(pattern), strlen(text), strlen(text), ' ', '-', ' ', 'f', '+');
		fprintf(file, " | strlen(text)(%llu) - strlen(pattern)(%llu) (=%llu)\n", strlen(text), strlen(pattern), strlen(text) - strlen(pattern));
		fprintf(file, " %s\n\n", text);
		i = 0;
		while (i <= strlen(text) - strlen(pattern)) {
				fprintf(file, "\n\n");
			fprintf(file, "current_step: i = %llu, k = %llu\n", i, k);
			if (k < strlen(pattern)) {
				Marker::print(file, -1, i, strlen(text), ' ', '-', ' ', 's', '+');
				fprintf(file, " | i(%llu)\n", i);
				Marker::print(file, i, i + strlen(pattern), strlen(text), ' ', '-', ' ', '+', '+');
				fprintf(file, " | i(%llu) + strlen(pattern)(%llu) (=%llu)\n", i, strlen(pattern), i + strlen(pattern));
				Marker::print(file, i + strlen(pattern), i + strlen(pattern) - 1, strlen(text), ' ', '-', ' ', '+', '+');
				fprintf(file, " | i{%llu) + strlen(pattern)(%llu) - 1 (=%llu)\n", i, strlen(pattern), i + strlen(pattern) - 1);
				Marker::print(file, i + strlen(pattern) - 1, i + strlen(pattern) - 1 - k, strlen(text), ' ', '-', ' ', '+', 'f');
				fprintf(file, " | i{%llu) + strlen(pattern)(%llu) - 1 - k(%llu) (=%llu)\n", i, strlen(pattern), k, i + strlen(pattern) - 1 - k);
				fprintf(file, " %s\n", text);
				Marker::print(file, i + strlen(pattern) - 1 - k, i + strlen(pattern) - 1, i + strlen(pattern) - 1, ' ', '=', ' ', (text[i + strlen(pattern) - 1 - k] == pattern[strlen(pattern) - 1 - k] ? '=' : '/'), '=');
				fprintf(file, "\n %*s\n", i + strlen(pattern), pattern);
				Marker::print(file, i + strlen(pattern) - 1, i + strlen(pattern) - 1 - k, strlen(text), ' ', '-', ' ', '+', 'f');
				fprintf(file, " | strlen(pattern)(%llu) - 1 - k(%llu) (=%llu)\n", strlen(pattern), k, strlen(pattern) - 1 - k);
				Marker::print(file, i + strlen(pattern), i + strlen(pattern) - 1, strlen(text), ' ', '-', ' ', '+', '+');
				fprintf(file, " | strlen(pattern)(%llu) - 1 (=%llu)\n", strlen(pattern), strlen(pattern) - 1);
				Marker::print(file, i - 1, i + strlen(pattern), strlen(text), ' ', '-', ' ', 's', '+');
				fprintf(file, " | strlen(pattern)(%llu) (=%llu)\n", strlen(pattern), strlen(pattern));
			}
			if (text[i + strlen(pattern) - 1 - k] == pattern[strlen(pattern) - 1 - k] && k < strlen(pattern)) {	//pretty basic stuff ngl
				++k;
			}
			else {
				if (k == strlen(pattern)) {
					fprintf(file, "\n\tmatch\n\n");
				}
				shiftbc = strlen(pattern) - 1 - k - bc[text[i + strlen(pattern) - 1 - k] - 'A'];
				shiftgs = strlen(pattern) - k - gs[strlen(pattern) - k];
				fprintf(file, "shiftbc = %lld, shiftgs = %lld\n", shiftbc, shiftgs);
				if (shiftbc > shiftgs) {
					fprintf(file, "shifting by using the bad character rule\n");
					i = i + shiftbc;
				}
				else {
					fprintf(file, "shifting by using the good suffix rule\n");
					i = i + shiftgs;
				}
				k = 0;
			}
		}
		delete[] bc;
		delete[] gs;
	}
}
void bm::find_all_occurences_lean(FILE* file, const char* text, const char* pattern) {
	if (strlen(text) < strlen(pattern)) {
		fprintf(file, "ERROR: Text '%s' is smaller than the pattern '%s', there's no point in matching them.\n", text, pattern);
		exit(1);
	}
	else {
		int64_t* bc = bm::calculate_last_bad_character_lean(file, pattern);
		int64_t* gs = bm::calculate_second_to_last_good_suffix_lean(file, pattern);
		if (bc == nullptr || gs == nullptr) {
			fprintf(file, "ERROR: Failed to allocate memory on the heap.\n");
			exit(1);
		}
		uint64_t i = 0, k = 0;
		int64_t shiftbc, shiftgs;
		while (i <= strlen(text) - strlen(pattern)) {
			if (text[i + strlen(pattern) - 1 - k] == pattern[strlen(pattern) - 1 - k] && k < strlen(pattern)) {	//pretty basic stuff ngl
				++k;
			}
			else {
				if (k == strlen(pattern)) {
					fprintf(file, "%llu ", i);
				}
				shiftbc = strlen(pattern) - 1 - k - bc[text[i + strlen(pattern) - 1 - k] - 'A'];
				shiftgs = strlen(pattern) - k - gs[strlen(pattern) - k];
				i = i + std::max(shiftbc, shiftgs);
				k = 0;
			}
		}
		if (ftell(file) != 0) {
			fseek(file, -1, SEEK_CUR);
			fprintf(file, "\n");
		}
		delete[] bc;
		delete[] gs;
	}
}
